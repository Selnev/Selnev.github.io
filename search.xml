<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数论笔记集</title>
      <link href="/2021/07/13/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0%E9%9B%86/"/>
      <url>/2021/07/13/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-素数与因数之章"><a href="#1-素数与因数之章" class="headerlink" title="1. 素数与因数之章"></a>1. 素数与因数之章</h2><h3 id="1-筛法"><a href="#1-筛法" class="headerlink" title="1. 筛法"></a>1. 筛法</h3><h4 id="埃拉托斯特尼筛法"><a href="#埃拉托斯特尼筛法" class="headerlink" title="埃拉托斯特尼筛法"></a>埃拉托斯特尼筛法</h4><blockquote><p>埃拉托斯特尼筛法, 简称埃氏筛法, 用于筛选 $ n $ 以内的质数</p></blockquote><h5 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h5><p>首先, 找到 $ n $ 以内的质数, 最容易被想到的判断方法当然是暴力算法, 一个一个判断是否是质数:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 时间复杂度 O(n ^ 2) 空间复杂度 O(1)</span><span class="token keyword">void</span> <span class="token function">IsPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但明显, 时间复杂度过高了。但因为若 $ n $ 有一个因数 $ x \leq \sqrt{n} $ , 则 $ n $ 还有因数 $ \frac{n}{x} \geq \sqrt{n} $, 所以可以只枚举到 $ \sqrt{n} $ 即可, 可以优化此算法:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 时间复杂度 O(n ^ 3/2) 空间复杂度 O(1)</span><span class="token keyword">void</span> <span class="token function">IsPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">Prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但时间复杂度仍然很高。但由上面的算法枚举因数的想法, 可逆向思考枚举倍数。于是便有筛法:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 时间复杂度 O(n log(n)) 空间复杂度 O(n)</span><span class="token keyword">bool</span> prime<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Prime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    prime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">*</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span>            prime<span class="token punctuation">[</span>i <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一定优化, 但还不够快。但其实经过观察, 可得以下几个结论:</p><ol><li>若一个数是合数, 则其倍数已被其因数筛去了。</li><li>$ j $ 可从 $ i $ 开始枚举, 因为 $ j &lt; i $ 筛去的数在之前 $ i $ 等于现在的 $ j $ 时已经筛去了。</li></ol><p>所以这些重复筛去的可以跳过, 所以得:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 时间复杂度 O(n log(log(n))) 空间复杂度 O(n)</span><span class="token keyword">bool</span> prime<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Eratosthenes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> i <span class="token operator">*</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span>            prime<span class="token punctuation">[</span>i <span class="token operator">*</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是埃氏筛, 时间复杂度 $ O(n \log_{2} \log_{2} n)$ , 空间复杂度 $ O(n) $。当然还可以再优化一些, 但此写法为基础写法, 其他便不再赘述。</p><h4 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h4><blockquote><p>欧拉筛法, 也称线性筛, 简称欧拉筛, 同样用于筛选 $ n $ 以内的素数</p></blockquote><p>埃氏筛固然好, 好写, 但时间复杂度后面带的两个 $ log $ 实在是令人不爽。那有没有时间复杂度 $ O(n) $ 的筛法呢? 当然有, 那就是欧拉筛法。</p><h5 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h5><p>首先若想实现时间复杂度为线性的话, 每个数字只会被筛一次, 所以欧拉筛的思想为:</p><p>首先, 设一个数 $ n = ab $ , 其中 $ a $ 为 $ n $ 的最小质因数。</p><p>然后我们可以枚举 $ b $ , 原因如下:</p><blockquote><p>假设有数 $ m = bp $ , 其中 $ p $ 为 $ m $ 的最小质因数, 且 $ p &gt; b $</p><p>设 $ b = kc $ , 其中 $ k $ 为 $ b $ 的最小质因数, 则:</p><blockquote><p>$ \because m \neq 0$</p><p>$ \therefore b \neq 0 $</p><p>$ \therefore c &gt; 0 $</p><p>$ \because b = kc, b &lt; p $</p><p>$ \therefore kc &lt; p $</p><p>$ \therefore k &lt; \frac{p}{c} $</p><p>又 $ \because c &gt; 0 $</p><p>$ \therefore \frac{p}{c} &lt; p $</p><p>$ \therefore k &lt; p $</p><p>又 $ \because k $ 是质数</p><p>$ \therefore k $ 是 $ n $ 的最小质因数</p><p>与假设相矛盾</p></blockquote><p>$ \therefore 综上: 若 n = ab, 且 a 为 n 的最小质因数, 则 a \leq b $</p></blockquote><p>因为 $ a &lt; b $ , 所以当我们枚举 $ b $ 时, 可取的 $ a $ 值已经求出了, 直接枚举之前算出的质数即可。</p><p>但有因为这里枚举的是 $ b $ , 所以可能还没枚举到这个数真正的 $ b $ , 可能就会有一些其他数先筛到它了, 比如 12 是先被 4 筛到, 而不是被 6 筛掉。所以要在枚举 $ a $ 时判断, 若 $ b \equiv 0 (mod\ a) $ , 则完成这一次筛选后就不再筛选了, 原因如下:</p><blockquote><p>若有 $ m = ab $ , 其中 $ a $ 是质数, 且 $ b \geq a $ , $ b \equiv 0 (mod\ a) $</p><p>则对于后来枚举到的质数 $ p $ :</p><blockquote><p>$ \because b \equiv 0 (mod\ a) $</p><p>$ \therefore $ 设 $ b = ak $</p><p>$ \therefore $ 后来筛到的 $ b’ = apk $</p><p>根据定义得:</p><p>$ b’ $ 的最小质因数为 $ p $</p><p>$ \because a, p $ 都是质数</p><p>又 $ \because a &lt; p $</p><p>$ \therefore a $ 是 $ b’ $ 的最小质因数</p><p>与假设相矛盾</p></blockquote><p>$ \therefore 当 $ $ b \equiv 0 (mod\ a) $ 时, $ a $ 不能取更大的值, 否则将取得错误的值</p></blockquote><p>所以由上面的结论可得:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 时间复杂度 O(n), 空间复杂度 O(n + ln(n)/n)</span><span class="token keyword">bool</span> IsPrime<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> Prime<span class="token punctuation">[</span>MAXM<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Euler</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    IsPrime<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>IsPrime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> Prime<span class="token punctuation">[</span><span class="token operator">++</span> Prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> Prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            IsPrime<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>附: 与欧拉有关的知识都有大片证明, 读者若不注重证明方法可跳过不读</p></blockquote><hr><h3 id="2-因数"><a href="#2-因数" class="headerlink" title="2. 因数"></a>2. 因数</h3><h4 id="分解因数"><a href="#分解因数" class="headerlink" title="分解因数"></a>分解因数</h4><blockquote><p>用处并不是很大</p></blockquote><h5 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h5><p>因为分解因数并不是很常用, 所以此处就只展示一种暴力算法。当然, 这里是优化过的, 是按讲筛法时判断素数的优化来优化的:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 时间复杂度 O(n) 空间复杂度 O(1)</span><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> i <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> n <span class="token operator">/</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h4><blockquote><p>顾名思义, 用于分解一个数的质因数</p></blockquote><h5 id="主要思想-3"><a href="#主要思想-3" class="headerlink" title="主要思想"></a>主要思想</h5><p>首先, 仍然是一个浅显易懂的暴力算法, 但不同的是, 一般来说, 这时初学者用得很多的一种算法:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 最差情况时间复杂度 O(n) 最优情况时间复杂度 O(log(n)) 空间复杂度 O(1)</span><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> n <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> n <span class="token operator">/=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过对于某些卡时间的题,  这种算法可以按之前分解因数的方法, 只判断到 $ \sqrt{n} $ 即可:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 最差情况时间复杂度 O(n ^ 1/2) 最优情况时间复杂度 O(log(n)) 空间复杂度 O(1)</span><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> n <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> n <span class="token operator">/=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之所以可以将 $ i $ 限制在变化的 $ n $ 之中, 是因为一个数不可能存在两个比其开方还大的因数。</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 学习笔记</title>
      <link href="/2021/07/08/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/08/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇是笔者在暑假自学 Java 后的总结, 所以示例较少, 归纳较多。</p></blockquote><h2 id="初识-Java"><a href="#初识-Java" class="headerlink" title="初识 Java"></a>初识 Java</h2><p>第一次接触 Java, 就觉得除了 Java 类的封装以外, 都和 C++ 挺类似的。<br>因为笔者已有一定 C++ 基础, 所以学 Java 的语法还是比较容易的。<br>另外如果还没有 IDE 的话, 可以看<a href="https://selnev.github.io/2021/07/03/%E5%B8%B8%E8%A7%81-IDE-%E5%8F%8A%E4%B8%8B%E8%BD%BD/">本博客这篇文章</a> 的 Java 部分(如果没有 Java 的话, 可以去<a href="https://www.java.com/">Oracle官网</a> 看看)。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p>这是每一次学习编程语言的第一个程序, 没有它你的程序就没有灵魂。话不多说，直接上代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://z3.ax1x.com/2021/07/09/RjhdOK.png"></p><p>这几行代码很简单, 但有些细节要注意:</p><blockquote><p>首先外面的 <code>public class</code> 定义的类名必须和文件名一样, 不然会报错:<br><img src="https://z3.ax1x.com/2021/07/09/Rjh0eO.png"><br>另外 Java 中字符串只能是由双引号括起来的, 不像 Python 一样都行</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见 IDE 及下载</title>
      <link href="/2021/07/03/%E5%B8%B8%E8%A7%81-IDE-%E5%8F%8A%E4%B8%8B%E8%BD%BD/"/>
      <url>/2021/07/03/%E5%B8%B8%E8%A7%81-IDE-%E5%8F%8A%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此处先介绍 C++, Python 和 Java 的 IDE, 其他语言日后补充</p></blockquote><h2 id="1-C"><a href="#1-C" class="headerlink" title="1. C++"></a>1. C++</h2><blockquote><p>C++ IDE有许多, 此处只展示了 3 种 (笔者也只在用前两种)</p></blockquote><hr><h3 id="Dev-c"><a href="#Dev-c" class="headerlink" title="Dev-c++"></a>Dev-c++</h3><p><a href="https://sm.myapp.com/original/Development/Dev-Cpp_5.11_TDM-GCC_4.9.2_Setup.exe">直接下载传送门</a></p><p>OIer 们的常用 IDE, 建议用来写简单算法类, 写项目或 GUI 经常报错 (至少我是)。<br>另外, 不得不提的是它的 UI 真的是 (自行体会) ……</p><p><img src="https://z3.ax1x.com/2021/07/03/R2dQsK.png"></p><h3 id="Clion"><a href="#Clion" class="headerlink" title="Clion"></a>Clion</h3><p><a href="https://www.jetbrains.com/clion/">JetBrain Clion 传送门</a></p><p>JetBrain 开发, 开发项目很不错, 就是 Cmake 比上面的 Dev-c++ 编译慢了一些, 但无伤大雅 (UI 都好看了许多) 。</p><p><img src="https://z3.ax1x.com/2021/07/03/R20KHO.png"></p><h3 id="Visual-C"><a href="#Visual-C" class="headerlink" title="Visual C++"></a>Visual C++</h3><p><a href="https://visualstudio.microsoft.com/zh-hans/vs/features/cplusplus/">Visual C++传送门</a></p><p>Microsoft 的 IDE, 用户不少, 笔者也曾经想安装一下, 但最后因一些位置的原因, 在下载时电脑硬盘被烧坏了 (所以此处没有图, 是因为我没有再安装它了) ……</p><hr><h2 id="2-Python"><a href="#2-Python" class="headerlink" title="2. Python"></a>2. Python</h2><blockquote><p>本人学识浅陋, 此处直接介绍一种笔者一直在用的 IDE (Python 自带的 IDE 就不用说了吧?)</p></blockquote><h3 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h3><p><a href="https://www.jetbrains.com/pycharm/">JetBrain Pycharm 传送门</a></p><p>这个 IDE 也和 Clion 一样由 JetBrains 开发, 优点根本数不清, 而且用它也可以编写 Markdown (本文部分就是在上面编写的)。</p><p><img src="https://z3.ax1x.com/2021/07/03/R2rYvR.png"></p><hr><h2 id="3-Java"><a href="#3-Java" class="headerlink" title="3. Java"></a>3. Java</h2><p><a href="https://www.jetbrains.com/idea/">JetBrain IntelliJ IDEA 传送门</a></p><p>同样, 也是由 JetBrains 开发的 IntelliJ IDEA(也被简称为 IDEA), 是很不错的, 笔者开始使用它后就再也没有装其他 Java IDE 了。</p><p><img src="https://z3.ax1x.com/2021/07/09/RjhdOK.png"></p><hr><h2 id="关于-JetBrains"><a href="#关于-JetBrains" class="headerlink" title="关于 JetBrains"></a>关于 JetBrains</h2><p><a href="https://www.jetbrains.com/">JetBrains 的链接</a></p><p>JetBrains 是一家捷克的开发 IDE 的公司,<br>笔者只使用了 Clion, Pycharm 和 IntelliJ IDEA。后两者使用的是 Community 版。<br>如果有钱也可以尝试使用 Professional 版。<br>当然, 你也可以尝试一下买 JetBrains 的全家桶……</p><p><img src="https://z3.ax1x.com/2021/07/03/R2ciss.png"></p><p>目前(2021.7.3)<strong>只</strong><span class="github-emoji"><span>😀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f600.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>需要 US $ 649.00 (是 $ 而不是 ￥)…… </p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客大事记</title>
      <link href="/2021/06/26/%E5%8D%9A%E5%AE%A2%E5%A4%A7%E4%BA%8B%E8%AE%B0/"/>
      <url>/2021/06/26/%E5%8D%9A%E5%AE%A2%E5%A4%A7%E4%BA%8B%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>2021-06-25: 开始开发博客</p><p>2021-06-26: 更换主题, 投入使用, 继续开发</p><p>2021-07-2: 增加 $valine$Q 评论系统</p><hr><p>~~ 没有更多了 ~~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
